import numpy as np
import pandas as pd
import os
import gc
import warnings;
warnings.filterwarnings('ignore')


#d1 = pd.read_csv("../ketqua/data/DatatrainTEST.csv") #DatatrainTEST
#d1 = pd.read_csv("../ketqua/data/DataTrainLabels1.csv").append(pd.read_csv("../ketqua/data/DataTrainLabels2.csv")).append(pd.read_csv("../ketqua/data/DataTrainLabels3.csv")).append(pd.read_csv("../ketqua/data/DataTrainLabels4.csv"))
d1 = pd.read_csv("../ketqua/dataF/DataTrainLabels1.csv").append(pd.read_csv("../ketqua/dataF/DataTrainLabels2.csv")).append(pd.read_csv("../ketqua/dataF/DataTrainLabels3.csv")).append(pd.read_csv("../ketqua/dataF/DataTrainLabels4.csv"))

print(d1.shape);
gc.collect();

# Chia dl thành 8:1:1 (train : test : val)
from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split( (d1.iloc[:,0:65536]), (d1['Class'] - 1) , test_size=0.1)
X_train, X_val, Y_train, Y_val = train_test_split(X_train, Y_train, test_size = (0.1/0.9))

del d1
gc.collect();

# Configuration options
feature_vector_length = 65536   # Độ dài đặc trưng của vector
num_classes = len(np.unique(Y_train))   # số nhãn của tập DL
labels = np.unique(Y_train)     # nhãn duy nhất

X_train = X_train.astype('float32') 
X_test  = X_test.astype('float32')

from tensorflow.keras.utils import to_categorical
Y_train = to_categorical(Y_train, num_classes)
Y_test = to_categorical(Y_test, num_classes)
Y_val = to_categorical(Y_val, num_classes)

# Set the input shape(Đặt hình dạng đầu vào)
input_shape = (feature_vector_length,)
  
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from keras.layers import Dropout, Conv1D, Flatten, MaxPool1D
from keras import layers

# Create the model MLP
model = Sequential()

model.add(layers.Embedding(256,256))
model.add(layers.Conv1D(256, kernel_size=3, activation='relu' ))
model.add(layers.MaxPooling1D(pool_size=2))
model.add(layers.Flatten())
model.add(layers.Dense(512, activation='relu'))
model.add(layers.Dropout(0.2))
model.add(layers.Dense(512, activation='relu'))
model.add(layers.Dropout(0.2))
model.add(layers.Dense(num_classes, activation='softmax'))

# Configure the model and start training(Định cấu hình mô hình và bắt đầu đào tạo)
model.compile(loss='mse', optimizer='adam', metrics=['accuracy'])
model.summary()

model.fit(X_train, Y_train, epochs=10, verbose=1, validation_split=0.1, validation_data = (X_val, Y_val) )

# save the model
from tensorflow import keras
model.save('../ketqua/model_CNN')

# Test the model after training(Kiểm tra mô hình sau khi đào tạo)
test_results = model.evaluate(X_test, Y_test, verbose=1)
print(f'Test results - Loss: {test_results[0]} - Accuracy: {test_results[1]}%')

# predict crisp classes for test set(dự đoán các lớp nhãn cho bộ thử nghiệm)
y_pred = model.predict_classes(X_test)

Y_test2 = np.argmax(Y_test, axis=1)

print("y_pred: \n",np.unique(y_pred))
print("Y_test2 : \n",np.unique(Y_test2))

# Accuracy: (tp + tn) / (p + n)
from sklearn.metrics import accuracy_score
accuracy = accuracy_score(Y_test2, y_pred)
print('Accuracy: %f' % accuracy)


"""
# Accuracy: (tp + tn) / (p + n)
from sklearn.metrics import accuracy_score
accuracy = accuracy_score(Y_test2, y_pred)
print('Accuracy: %f' % accuracy)

# Precision tp / (tp + fp)
from sklearn.metrics import precision_score
precision = precision_score(Y_test2, y_pred, pos_label='positive', average='micro')
print('Precision: %f' % precision)

# Recall: tp / (tp + fn)
from sklearn.metrics import recall_score
recall = recall_score(Y_test2, y_pred, pos_label='positive', average='micro')
print('Recall: %f' % recall)

# F1: 2 tp / (2 tp + fp + fn)
from sklearn.metrics import f1_score
f1 = f1_score(Y_test2, y_pred, pos_label='positive', average='micro')
print('F1 score: %f' % f1)
"""


#   tên nhãn
nhan = ['Ramnit', 'Lollipop', 'Kelihos_ver3', 'Vundo', 'Simda', 'Tracur', 'Kelihos_ver1' , 'Obfuscator.ACY', 'Gatak']

# Classification report for precision, recall, f1-score and accuracy (báo cáo phân loại)
from sklearn.metrics import classification_report
matrixXXX = classification_report(Y_test2, y_pred, target_names=nhan, labels=labels)
print('\n Classification report : \n',matrixXXX)

# create Confusion matrix
from sklearn.metrics import confusion_matrix
Cmatrix = confusion_matrix(Y_test2, y_pred, labels=labels, normalize='all')

print("\n\n", Cmatrix)

"""
# Tạo biểu đồ cho Confusion matrix
from sklearn.metrics import ConfusionMatrixDisplay
from matplotlib import pyplot as plt
cmd = ConfusionMatrixDisplay(Cmatrix, display_labels=nhan)
cmd.plot(cmap='Blues', xticks_rotation='vertical')
plt.savefig('../ketqua/model_CNN_CM.png')



# Compute ROC curve and ROC area for each class 
# (Tính đường cong ROC và diện tích ROC cho mỗi lớp)
from scipy import interp
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc   
pred_prob = model.predict_proba(X_test)
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(num_classes):
    fpr[i], tpr[i], _ = roc_curve(Y_test[:, i], pred_prob[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Compute micro-average ROC curve and ROC area
fpr['micro'], tpr['micro'], _ = roc_curve(Y_test.ravel(), pred_prob.ravel())
roc_auc['micro'] = auc(fpr['micro'], tpr['micro'])

fig=plt.figure(figsize=(10, 10))
fig.add_subplot()
lw = 2 # line_width
plt.plot(fpr['micro'], tpr['micro'], color='darkorange', linestyle='--',
         lw=lw, label='ROC curve (area = %0.4f)' % roc_auc['micro'])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC curve for multi-classification using MLP model')
plt.legend()
#plt.show()
plt.savefig('../ketqua/model_CNN_ROC.png')

"""

print("--------------- [The end] ------------------")


